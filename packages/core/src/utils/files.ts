/**
 * File Utilities
 * Functions for file operations during plugin management
 * 
 * Requirements: 3.2, 3.4
 */
import fs from 'fs-extra';
import path from 'path';

/**
 * Represents a file that was generated by a plugin
 */
export interface GeneratedFile {
  /** Relative path from project root */
  path: string;
  /** Plugin that generated this file */
  plugin: string;
  /** Timestamp when the file was generated */
  generatedAt: string;
}

/**
 * Manifest file that tracks generated files
 */
export interface GeneratedFilesManifest {
  /** Version of the manifest format */
  version: number;
  /** List of generated files */
  files: GeneratedFile[];
}

const MANIFEST_FILE = '.scaforge/generated-files.json';
const MANIFEST_VERSION = 1;

/**
 * Gets the path to the manifest file
 */
function getManifestPath(projectRoot: string): string {
  return path.join(projectRoot, MANIFEST_FILE);
}

/**
 * Loads the generated files manifest
 */
export async function loadManifest(projectRoot: string): Promise<GeneratedFilesManifest> {
  const manifestPath = getManifestPath(projectRoot);
  
  if (await fs.pathExists(manifestPath)) {
    return fs.readJson(manifestPath);
  }
  
  return {
    version: MANIFEST_VERSION,
    files: [],
  };
}

/**
 * Saves the generated files manifest
 */
export async function saveManifest(
  projectRoot: string,
  manifest: GeneratedFilesManifest
): Promise<void> {
  const manifestPath = getManifestPath(projectRoot);
  await fs.ensureDir(path.dirname(manifestPath));
  await fs.writeJson(manifestPath, manifest, { spaces: 2 });
}


/**
 * Tracks a generated file in the manifest
 */
export async function trackGeneratedFile(
  projectRoot: string,
  filePath: string,
  pluginName: string
): Promise<void> {
  const manifest = await loadManifest(projectRoot);
  
  // Check if file is already tracked
  const existingIndex = manifest.files.findIndex(f => f.path === filePath);
  
  const entry: GeneratedFile = {
    path: filePath,
    plugin: pluginName,
    generatedAt: new Date().toISOString(),
  };
  
  if (existingIndex >= 0) {
    manifest.files[existingIndex] = entry;
  } else {
    manifest.files.push(entry);
  }
  
  await saveManifest(projectRoot, manifest);
}

/**
 * Gets all files generated by a specific plugin
 */
export async function getPluginFiles(
  projectRoot: string,
  pluginName: string
): Promise<GeneratedFile[]> {
  const manifest = await loadManifest(projectRoot);
  return manifest.files.filter(f => f.plugin === pluginName);
}

/**
 * Removes tracking for files generated by a plugin
 */
export async function untrackPluginFiles(
  projectRoot: string,
  pluginName: string
): Promise<string[]> {
  const manifest = await loadManifest(projectRoot);
  const removedFiles = manifest.files
    .filter(f => f.plugin === pluginName)
    .map(f => f.path);
  
  manifest.files = manifest.files.filter(f => f.plugin !== pluginName);
  await saveManifest(projectRoot, manifest);
  
  return removedFiles;
}

/**
 * Writes a file and tracks it in the manifest
 */
export async function writeGeneratedFile(
  projectRoot: string,
  filePath: string,
  content: string,
  pluginName: string
): Promise<void> {
  const fullPath = path.join(projectRoot, filePath);
  
  // Ensure directory exists
  await fs.ensureDir(path.dirname(fullPath));
  
  // Write the file
  await fs.writeFile(fullPath, content, 'utf-8');
  
  // Track in manifest
  await trackGeneratedFile(projectRoot, filePath, pluginName);
}

/**
 * Removes a generated file and untracks it
 */
export async function removeGeneratedFile(
  projectRoot: string,
  filePath: string
): Promise<boolean> {
  const fullPath = path.join(projectRoot, filePath);
  
  if (await fs.pathExists(fullPath)) {
    await fs.remove(fullPath);
    
    // Update manifest
    const manifest = await loadManifest(projectRoot);
    manifest.files = manifest.files.filter(f => f.path !== filePath);
    await saveManifest(projectRoot, manifest);
    
    return true;
  }
  
  return false;
}

/**
 * Removes all files generated by a plugin
 */
export async function removePluginFiles(
  projectRoot: string,
  pluginName: string
): Promise<string[]> {
  const files = await getPluginFiles(projectRoot, pluginName);
  const removedFiles: string[] = [];
  
  for (const file of files) {
    const fullPath = path.join(projectRoot, file.path);
    if (await fs.pathExists(fullPath)) {
      await fs.remove(fullPath);
      removedFiles.push(file.path);
    }
  }
  
  // Update manifest
  await untrackPluginFiles(projectRoot, pluginName);
  
  return removedFiles;
}

/**
 * Checks if a file exists in the project
 */
export async function fileExists(
  projectRoot: string,
  filePath: string
): Promise<boolean> {
  const fullPath = path.join(projectRoot, filePath);
  return fs.pathExists(fullPath);
}

/**
 * Reads a file from the project
 */
export async function readProjectFile(
  projectRoot: string,
  filePath: string
): Promise<string> {
  const fullPath = path.join(projectRoot, filePath);
  return fs.readFile(fullPath, 'utf-8');
}

/**
 * Creates a backup of a file before modification
 */
export async function createBackup(
  projectRoot: string,
  filePath: string
): Promise<string | null> {
  const fullPath = path.join(projectRoot, filePath);
  
  if (!(await fs.pathExists(fullPath))) {
    return null;
  }
  
  const backupDir = path.join(projectRoot, '.scaforge/backups');
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const backupPath = path.join(backupDir, `${filePath}.${timestamp}.bak`);
  
  await fs.ensureDir(path.dirname(backupPath));
  await fs.copy(fullPath, backupPath);
  
  // Return relative path from project root
  return path.relative(projectRoot, backupPath);
}

/**
 * Restores a file from backup
 */
export async function restoreFromBackup(
  projectRoot: string,
  backupPath: string,
  targetPath: string
): Promise<void> {
  const fullBackupPath = path.join(projectRoot, backupPath);
  const fullTargetPath = path.join(projectRoot, targetPath);
  
  if (!(await fs.pathExists(fullBackupPath))) {
    throw new Error(`Backup file not found: ${backupPath}`);
  }
  
  await fs.ensureDir(path.dirname(fullTargetPath));
  await fs.copy(fullBackupPath, fullTargetPath);
}
