/**
 * ORPC Plugin for Scaforge
 * OpenAPI-compatible RPC with excellent TypeScript support
 */
import { z } from 'zod';
import { definePlugin } from '@scaforge/core';

export const apiOrpcPlugin = definePlugin({
  name: 'api-orpc',
  displayName: 'ORPC',
  category: 'api',
  description: 'OpenAPI-compatible RPC with excellent TypeScript support',
  version: '1.0.0',
  
  supportedTemplates: ['nextjs', 'tanstack', 'nuxt'],
  
  packages: {
    dependencies: {
      '@orpc/server': '^0.0.1',
      '@orpc/client': '^0.0.1',
      '@orpc/react': '^0.0.1',
      '@orpc/openapi': '^0.0.1',
      'zod': '^3.22.0',
    },
  },
  
  configSchema: z.object({
    openapi: z.object({
      title: z.string().default('Scaforge API'),
      version: z.string().default('1.0.0'),
      description: z.string().default('API generated by Scaforge'),
    }).optional(),
    cors: z.object({
      origin: z.string().default('http://localhost:3000'),
      credentials: z.boolean().default(true),
    }).optional(),
    playground: z.boolean().default(true),
  }),
  
  files: [
    // ORPC Context
    {
      path: 'src/server/orpc/context.ts',
      template: `{{#if (hasPlugin 'auth-authjs')}}
import { auth } from '@/auth';
{{/if}}
{{#if (hasPlugin 'auth-clerk')}}
import { getAuth } from '@clerk/nextjs/server';
{{/if}}
{{#if (hasPlugin 'db-prisma')}}
import { prisma } from '@/lib/prisma';
{{/if}}

export interface Context {
  {{#if (hasPlugin 'auth-authjs')}}
  session?: Awaited<ReturnType<typeof auth>> | null;
  user?: Awaited<ReturnType<typeof auth>>['user'] | null;
  {{/if}}
  {{#if (hasPlugin 'auth-clerk')}}
  userId?: string | null;
  {{/if}}
  {{#if (hasPlugin 'db-prisma')}}
  prisma: typeof prisma;
  {{/if}}
}

export async function createContext(opts: { req?: any; res?: any }): Promise<Context> {
  {{#if (hasPlugin 'auth-authjs')}}
  const session = await auth();
  {{/if}}
  {{#if (hasPlugin 'auth-clerk')}}
  const { userId } = getAuth(opts.req);
  {{/if}}
  
  return {
    {{#if (hasPlugin 'auth-authjs')}}
    session,
    user: session?.user,
    {{/if}}
    {{#if (hasPlugin 'auth-clerk')}}
    userId,
    {{/if}}
    {{#if (hasPlugin 'db-prisma')}}
    prisma,
    {{/if}}
  };
}
`,
      overwrite: false,
    },
    
    // ORPC Router setup
    {
      path: 'src/server/orpc/index.ts',
      template: `import { createORPCHandler } from '@orpc/server';
import { z } from 'zod';
import type { Context } from './context';
{{#if (or (hasPlugin 'auth-authjs') (hasPlugin 'auth-clerk'))}}
import { ORPCError } from '@orpc/server';
{{/if}}

// Base procedure
export const procedure = createORPCHandler<Context>();

{{#if (or (hasPlugin 'auth-authjs') (hasPlugin 'auth-clerk'))}}
// Protected procedure that requires authentication
export const protectedProcedure = procedure.use(async ({ ctx, next }) => {
  {{#if (hasPlugin 'auth-authjs')}}
  if (!ctx.session?.user) {
    throw new ORPCError({
      code: 'UNAUTHORIZED',
      message: 'You must be logged in to access this resource',
    });
  }
  
  return next({
    ctx: {
      ...ctx,
      user: ctx.session.user,
    },
  });
  {{/if}}
  {{#if (hasPlugin 'auth-clerk')}}
  if (!ctx.userId) {
    throw new ORPCError({
      code: 'UNAUTHORIZED',
      message: 'You must be logged in to access this resource',
    });
  }
  
  return next({
    ctx: {
      ...ctx,
      userId: ctx.userId,
    },
  });
  {{/if}}
});
{{/if}}

// Export types for client
export type { Context };
`,
      overwrite: false,
    },
    
    // Example router
    {
      path: 'src/server/orpc/routers/example.ts',
      template: `import { z } from 'zod';
import { procedure{{#if (or (hasPlugin 'auth-authjs') (hasPlugin 'auth-clerk'))}}, protectedProcedure{{/if}} } from '../index';
{{#if (hasPlugin 'db-prisma')}}
import { ORPCError } from '@orpc/server';
{{/if}}

export const exampleRouter = {
  hello: procedure
    .input(z.object({ name: z.string().optional() }))
    .output(z.object({ greeting: z.string() }))
    .handler(async ({ input }) => {
      return {
        greeting: \`Hello \${input.name ?? 'World'}!\`,
      };
    }),

  {{#if (hasPlugin 'db-prisma')}}
  getUsers: procedure
    .input(z.object({
      limit: z.number().min(1).max(100).default(10),
      offset: z.number().min(0).default(0),
    }))
    .output(z.array(z.object({
      id: z.string(),
      name: z.string().nullable(),
      email: z.string(),
      createdAt: z.date(),
    })))
    .handler(async ({ input, ctx }) => {
      const users = await ctx.prisma.user.findMany({
        take: input.limit,
        skip: input.offset,
        orderBy: { createdAt: 'desc' },
      });
      
      return users;
    }),

  getUserById: procedure
    .input(z.object({ id: z.string() }))
    .output(z.object({
      id: z.string(),
      name: z.string().nullable(),
      email: z.string(),
      createdAt: z.date(),
      updatedAt: z.date(),
    }).nullable())
    .handler(async ({ input, ctx }) => {
      const user = await ctx.prisma.user.findUnique({
        where: { id: input.id },
      });
      
      return user;
    }),

  createUser: procedure
    .input(z.object({
      name: z.string().optional(),
      email: z.string().email(),
    }))
    .output(z.object({
      id: z.string(),
      name: z.string().nullable(),
      email: z.string(),
      createdAt: z.date(),
    }))
    .handler(async ({ input, ctx }) => {
      const user = await ctx.prisma.user.create({
        data: input,
      });
      
      return user;
    }),

  updateUser: procedure
    .input(z.object({
      id: z.string(),
      name: z.string().optional(),
      email: z.string().email().optional(),
    }))
    .output(z.object({
      id: z.string(),
      name: z.string().nullable(),
      email: z.string(),
      updatedAt: z.date(),
    }))
    .handler(async ({ input, ctx }) => {
      const { id, ...data } = input;
      
      const user = await ctx.prisma.user.findUnique({
        where: { id },
      });
      
      if (!user) {
        throw new ORPCError({
          code: 'NOT_FOUND',
          message: 'User not found',
        });
      }
      
      const updatedUser = await ctx.prisma.user.update({
        where: { id },
        data,
      });
      
      return updatedUser;
    }),

  deleteUser: procedure
    .input(z.object({ id: z.string() }))
    .output(z.object({ success: z.boolean() }))
    .handler(async ({ input, ctx }) => {
      const user = await ctx.prisma.user.findUnique({
        where: { id: input.id },
      });
      
      if (!user) {
        throw new ORPCError({
          code: 'NOT_FOUND',
          message: 'User not found',
        });
      }
      
      await ctx.prisma.user.delete({
        where: { id: input.id },
      });
      
      return { success: true };
    }),
  {{/if}}

  {{#if (or (hasPlugin 'auth-authjs') (hasPlugin 'auth-clerk'))}}
  getProfile: protectedProcedure
    .output(z.object({
      {{#if (hasPlugin 'auth-authjs')}}
      id: z.string(),
      name: z.string().nullable(),
      email: z.string().nullable(),
      {{/if}}
      {{#if (hasPlugin 'auth-clerk')}}
      userId: z.string(),
      {{/if}}
    }))
    .handler(async ({ ctx }) => {
      {{#if (hasPlugin 'auth-authjs')}}
      return {
        id: ctx.user.id!,
        name: ctx.user.name,
        email: ctx.user.email,
      };
      {{/if}}
      {{#if (hasPlugin 'auth-clerk')}}
      return {
        userId: ctx.userId,
      };
      {{/if}}
    }),
  {{/if}}
};
`,
      overwrite: false,
    },
    
    // Main app router
    {
      path: 'src/server/orpc/routers/index.ts',
      template: `import { exampleRouter } from './example';

/**
 * Main ORPC router
 * Add your routers here
 */
export const appRouter = {
  example: exampleRouter,
};

export type AppRouter = typeof appRouter;
`,
      overwrite: false,
    },
    
    // ORPC Server
    {
      path: 'src/server/orpc/server.ts',
      template: `import { createORPCHandler } from '@orpc/server';
import { generateOpenAPI } from '@orpc/openapi';
import { appRouter } from './routers';
import { createContext } from './context';

export const orpcHandler = createORPCHandler({
  router: appRouter,
  createContext,
  {{#if options.cors}}
  cors: {
    origin: '{{options.cors.origin}}',
    credentials: {{options.cors.credentials}},
  },
  {{/if}}
});

{{#if options.openapi}}
// Generate OpenAPI specification
export const openApiSpec = generateOpenAPI(appRouter, {
  info: {
    title: '{{options.openapi.title}}',
    version: '{{options.openapi.version}}',
    description: '{{options.openapi.description}}',
  },
  servers: [
    {
      url: '/api/orpc',
      description: 'Development server',
    },
  ],
});
{{/if}}
`,
      overwrite: false,
    },
    
    // Next.js API route
    {
      path: 'src/app/api/orpc/[...orpc]/route.ts',
      template: `import { orpcHandler } from '@/server/orpc/server';

export { orpcHandler as GET, orpcHandler as POST };
`,
      condition: { template: 'nextjs' },
      overwrite: false,
    },
    
    // OpenAPI route
    {
      path: 'src/app/api/openapi/route.ts',
      template: `import { openApiSpec } from '@/server/orpc/server';
import { NextResponse } from 'next/server';

export async function GET() {
  return NextResponse.json(openApiSpec);
}
`,
      condition: { template: 'nextjs' },
      overwrite: false,
    },
    
    // Client setup
    {
      path: 'src/lib/orpc/client.ts',
      template: `import { createORPCClient } from '@orpc/client';
import type { AppRouter } from '@/server/orpc/routers';

export const orpc = createORPCClient<AppRouter>({
  baseURL: '/api/orpc',
  {{#if options.cors}}
  fetch: (input, init) => {
    return fetch(input, {
      ...init,
      credentials: 'include',
    });
  },
  {{/if}}
});
`,
      condition: { template: 'nextjs' },
      overwrite: false,
    },
    
    // React hooks
    {
      path: 'src/lib/orpc/hooks.ts',
      template: `import { createORPCReact } from '@orpc/react';
import type { AppRouter } from '@/server/orpc/routers';
import { orpc } from './client';

export const { useQuery, useMutation, useInfiniteQuery } = createORPCReact<AppRouter>({
  client: orpc,
});
`,
      condition: { template: 'nextjs' },
      overwrite: false,
    },
    
    // Provider
    {
      path: 'src/lib/orpc/provider.tsx',
      template: `'use client';

import { ORPCProvider } from '@orpc/react';
import { orpc } from './client';

export function APIProvider({ children }: { children: React.ReactNode }) {
  return (
    <ORPCProvider client={orpc}>
      {children}
    </ORPCProvider>
  );
}
`,
      condition: { template: 'nextjs' },
      overwrite: false,
    },
    
    // Example usage component
    {
      path: 'src/components/examples/orpc-example.tsx',
      template: `'use client';

{{#if (eq template 'nextjs')}}
import { useQuery, useMutation } from '@/lib/orpc/hooks';
{{/if}}

export function ORPCExample() {
  {{#if (eq template 'nextjs')}}
  const { data, isLoading, error } = useQuery(['example', 'hello'], {
    name: 'ORPC',
  });

  {{#if (hasPlugin 'db-prisma')}}
  const { data: users } = useQuery(['example', 'getUsers'], {
    limit: 5,
    offset: 0,
  });

  const createUserMutation = useMutation(['example', 'createUser']);

  const handleCreateUser = async () => {
    try {
      await createUserMutation.mutateAsync({
        name: 'New User',
        email: 'user@example.com',
      });
    } catch (err) {
      console.error('Error creating user:', err);
    }
  };
  {{/if}}

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  {{/if}}

  return (
    <div className="p-6 max-w-md mx-auto bg-white rounded-xl shadow-lg">
      <h2 className="text-xl font-semibold mb-4">ORPC Example</h2>
      {{#if (eq template 'nextjs')}}
      <p className="text-gray-600">{data?.greeting}</p>
      
      {{#if (hasPlugin 'db-prisma')}}
      <div className="mt-4">
        <div className="flex justify-between items-center mb-2">
          <h3 className="font-medium">Users:</h3>
          <button
            onClick={handleCreateUser}
            disabled={createUserMutation.isLoading}
            className="px-3 py-1 bg-blue-500 text-white text-sm rounded hover:bg-blue-600 disabled:opacity-50"
          >
            {createUserMutation.isLoading ? 'Adding...' : 'Add User'}
          </button>
        </div>
        <ul className="space-y-1">
          {users?.map((user) => (
            <li key={user.id} className="text-sm text-gray-500">
              {user.name} ({user.email})
            </li>
          ))}
        </ul>
      </div>
      {{/if}}
      {{else}}
      <p className="text-gray-600">ORPC is configured! Check /api/orpc</p>
      {{/if}}
      
      <div className="mt-4 text-xs text-gray-400">
        {{#if options.openapi}}
        <a href="/api/openapi" className="underline">View OpenAPI Spec</a>
        {{/if}}
      </div>
    </div>
  );
}
`,
      overwrite: false,
    },
    
    // Nuxt plugin
    {
      path: 'plugins/orpc.client.ts',
      template: `import { createORPCClient } from '@orpc/client';
import type { AppRouter } from '~/server/orpc/routers';

export default defineNuxtPlugin(() => {
  const orpc = createORPCClient<AppRouter>({
    baseURL: '/api/orpc',
  });

  return {
    provide: {
      orpc,
    },
  };
});
`,
      condition: { template: 'nuxt' },
      overwrite: false,
    },
  ],
  
  // Integrations with other plugins
  integrations: [
    {
      plugin: 'auth-authjs',
      type: 'middleware',
      files: [
        {
          path: 'src/server/orpc/middleware/auth.ts',
          template: `import { ORPCError } from '@orpc/server';
import { procedure } from '../index';

/**
 * Auth middleware for ORPC procedures
 */
export const authMiddleware = procedure.use(async ({ ctx, next }) => {
  if (!ctx.session?.user) {
    throw new ORPCError({
      code: 'UNAUTHORIZED',
      message: 'You must be logged in to access this resource',
    });
  }
  
  return next({
    ctx: {
      ...ctx,
      user: ctx.session.user,
    },
  });
});

/**
 * Protected procedure that requires authentication
 */
export const protectedProcedure = authMiddleware;
`,
          overwrite: false,
        },
      ],
    },
    
    {
      plugin: 'auth-clerk',
      type: 'middleware',
      files: [
        {
          path: 'src/server/orpc/middleware/clerk-auth.ts',
          template: `import { ORPCError } from '@orpc/server';
import { procedure } from '../index';

/**
 * Clerk auth middleware for ORPC procedures
 */
export const clerkAuthMiddleware = procedure.use(async ({ ctx, next }) => {
  if (!ctx.userId) {
    throw new ORPCError({
      code: 'UNAUTHORIZED',
      message: 'You must be logged in to access this resource',
    });
  }
  
  return next({
    ctx: {
      ...ctx,
      userId: ctx.userId,
    },
  });
});

/**
 * Protected procedure that requires Clerk authentication
 */
export const protectedProcedure = clerkAuthMiddleware;
`,
          overwrite: false,
        },
      ],
    },
  ],
  
  postInstall: `üöÄ ORPC has been configured successfully!

Next steps:
1. {{#if (eq template 'nextjs')}}Wrap your app with APIProvider in your layout{{/if}}
2. Create your API procedures in src/server/orpc/routers/
3. Use the ORPC client in your components
4. {{#if (hasPlugin 'db-prisma')}}Check out the generated user procedures for database examples{{/if}}

API Endpoints:
- RPC: /api/orpc
{{#if options.openapi}}
- OpenAPI Spec: /api/openapi
{{/if}}

Key features:
- üîí **Type Safety** - End-to-end type safety
- üìñ **OpenAPI** - Automatic OpenAPI specification generation
- üéØ **Zod Validation** - Input/output validation with Zod
- {{#if (hasPlugin 'db-prisma')}}üóÑÔ∏è **Database Integration** - Seamless Prisma integration{{/if}}

Example usage:
{{#if (eq template 'nextjs')}}
\`\`\`tsx
import { useQuery } from '@/lib/orpc/hooks';

function MyComponent() {
  const { data, isLoading } = useQuery(['example', 'hello'], {
    name: 'World'
  });
  
  if (isLoading) return <div>Loading...</div>;
  return <div>{data?.greeting}</div>;
}
\`\`\`
{{/if}}

Documentation: https://orpc.unnoq.com/`,
});

export default apiOrpcPlugin;